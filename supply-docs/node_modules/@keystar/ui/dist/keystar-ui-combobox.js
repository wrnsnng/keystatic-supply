'use client';
import { getChildNodes } from '@react-stately/collections';
export { Item, Section } from '@react-stately/collections';
import { c } from './react-compiler-runtime-19061925.js';
import { useComboBox } from '@react-aria/combobox';
import { useFilter, useLocalizedStringFormatter } from '@react-aria/i18n';
import { setInteractionModality, useHover, PressResponder } from '@react-aria/interactions';
import { useObjectRef, mergeProps, useId, useResizeObserver, useLayoutEffect, chain, useLabels } from '@react-aria/utils';
import { useComboBoxState } from '@react-stately/combobox';
import React, { useRef, useState, useCallback, useEffect, useMemo } from 'react';
import { useFieldButton, ClearButton, FieldButton } from '@keystar/ui/button';
import { useProviderProps } from '@keystar/ui/core';
import { FieldPrimitive } from '@keystar/ui/field';
import { Icon } from '@keystar/ui/icon';
import { chevronDownIcon } from '@keystar/ui/icon/icons/chevronDownIcon';
import { Flex } from '@keystar/ui/layout';
import { useListBoxLayout, ListBoxBase, listStyles } from '@keystar/ui/listbox';
import { Tray, Popover } from '@keystar/ui/overlays';
import { ProgressCircle } from '@keystar/ui/progress';
import { ClassList, FocusRing, toDataAttributes, css, tokenSchema, transition, useIsMobileDevice } from '@keystar/ui/style';
import { TextFieldPrimitive, validateTextFieldProps } from '@keystar/ui/text-field';
import { Text } from '@keystar/ui/typography';
import { useButton } from '@react-aria/button';
import { useDialog } from '@react-aria/dialog';
import { focusSafely, FocusScope } from '@react-aria/focus';
import { useField } from '@react-aria/label';
import { useOverlayTrigger, DismissButton, ariaHideOutside } from '@react-aria/overlays';
import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { useFormValidationState } from '@react-stately/form';
import { useListState, ListCollection } from '@react-stately/list';
import { useMenuTriggerState } from '@react-stately/menu';
import { useControlledState } from '@react-stately/utils';
import { u as usePrevious } from './usePrevious-6abf6421.js';
import { useMenuTrigger } from '@react-aria/menu';
import { listData, getItemId } from '@react-aria/listbox';
import { ListKeyboardDelegate, useSelectableCollection } from '@react-aria/selection';
import { useTextField } from '@react-aria/textfield';

const comboboxClassList = new ClassList('Combobox', ['input', 'mobile-trigger']);

const localizedMessages = {
  "ar-AE": {
    "clear": `مسح`,
    "invalid": `(غير صالح)`,
    "loading": `جارٍ التحميل...`,
    "noResults": `لا توجد نتائج`,
    "buttonLabel": `عرض المقترحات`,
    "listboxLabel": `مقترحات`
  },
  "bg-BG": {
    "clear": `Изчисти`,
    "invalid": `(невалиден)`,
    "loading": `Зареждане...`,
    "noResults": `Няма резултати`,
    "buttonLabel": `Покажи предложения`,
    "listboxLabel": `Предложения`
  },
  "cs-CZ": {
    "clear": `Vymazat`,
    "invalid": `(neplatné)`,
    "loading": `Načítání...`,
    "noResults": `Žádné výsledky`,
    "buttonLabel": `Zobrazit doporučení`,
    "listboxLabel": `Návrhy`
  },
  "da-DK": {
    "clear": `Ryd`,
    "invalid": `(ugyldig)`,
    "loading": `Indlæser ...`,
    "noResults": `Ingen resultater`,
    "buttonLabel": `Vis forslag`,
    "listboxLabel": `Forslag`
  },
  "de-DE": {
    "clear": `Löschen`,
    "invalid": `(ungültig)`,
    "loading": `Wird geladen...`,
    "noResults": `Keine Ergebnisse`,
    "buttonLabel": `Empfehlungen anzeigen`,
    "listboxLabel": `Empfehlungen`
  },
  "el-GR": {
    "clear": `Καθαρισμός`,
    "invalid": `(δεν ισχύει)`,
    "loading": `Φόρτωση...`,
    "noResults": `Χωρίς αποτέλεσμα`,
    "buttonLabel": `Προβολή προτάσεων`,
    "listboxLabel": `Προτάσεις`
  },
  "en-US": {
    "clear": `Clear`,
    "invalid": `(invalid)`,
    "loading": `Loading...`,
    "noResults": `No results`,
    "buttonLabel": `Show suggestions`,
    "listboxLabel": `Suggestions`
  },
  "es-ES": {
    "clear": `Borrar`,
    "invalid": `(no válido)`,
    "loading": `Cargando...`,
    "noResults": `Sin resultados`,
    "buttonLabel": `Mostrar sugerencias`,
    "listboxLabel": `Sugerencias`
  },
  "et-EE": {
    "clear": `Puhasta`,
    "invalid": `(kehtetu)`,
    "loading": `Laadimine...`,
    "noResults": `Tulemusi pole`,
    "buttonLabel": `Kuva soovitused`,
    "listboxLabel": `Soovitused`
  },
  "fi-FI": {
    "clear": `Kirkas`,
    "invalid": `(epäkelpo)`,
    "loading": `Ladataan...`,
    "noResults": `Ei tuloksia`,
    "buttonLabel": `Näytä ehdotukset`,
    "listboxLabel": `Ehdotukset`
  },
  "fr-FR": {
    "clear": `Effacer`,
    "invalid": `(non valide)`,
    "loading": `Chargement en cours...`,
    "noResults": `Aucun résultat`,
    "buttonLabel": `Afficher les suggestions`,
    "listboxLabel": `Suggestions`
  },
  "he-IL": {
    "clear": `נקי`,
    "invalid": `(לא חוקי)`,
    "loading": `טוען...`,
    "noResults": `אין תוצאות`,
    "buttonLabel": `הצג הצעות`,
    "listboxLabel": `הצעות`
  },
  "hr-HR": {
    "clear": `Izbriši`,
    "invalid": `(nevažeće)`,
    "loading": `Učitavam...`,
    "noResults": `Nema rezultata`,
    "buttonLabel": `Prikaži prijedloge`,
    "listboxLabel": `Prijedlozi`
  },
  "hu-HU": {
    "clear": `Törlés`,
    "invalid": `(érvénytelen)`,
    "loading": `Betöltés folyamatban…`,
    "noResults": `Nincsenek találatok`,
    "buttonLabel": `Javaslatok megjelenítése`,
    "listboxLabel": `Javaslatok`
  },
  "it-IT": {
    "clear": `Cancella`,
    "invalid": `(non valido)`,
    "loading": `Caricamento in corso...`,
    "noResults": `Nessun risultato`,
    "buttonLabel": `Mostra suggerimenti`,
    "listboxLabel": `Suggerimenti`
  },
  "ja-JP": {
    "clear": `クリア`,
    "invalid": `(無効)`,
    "loading": `読み込み中...`,
    "noResults": `結果なし`,
    "buttonLabel": `候補を表示`,
    "listboxLabel": `候補`
  },
  "ko-KR": {
    "clear": `지우기`,
    "invalid": `(유효하지 않음)`,
    "loading": `로드 중...`,
    "noResults": `결과 없음`,
    "buttonLabel": `제안 사항 표시`,
    "listboxLabel": `제안`
  },
  "lt-LT": {
    "clear": `Skaidrus`,
    "invalid": `(netinkama)`,
    "loading": `Įkeliama...`,
    "noResults": `Be rezultatų`,
    "buttonLabel": `Rodyti pasiūlymus`,
    "listboxLabel": `Pasiūlymai`
  },
  "lv-LV": {
    "clear": `Notīrīt`,
    "invalid": `(nederīgs)`,
    "loading": `Notiek ielāde...`,
    "noResults": `Nav rezultātu`,
    "buttonLabel": `Rādīt ieteikumus`,
    "listboxLabel": `Ieteikumi`
  },
  "nb-NO": {
    "clear": `Tøm`,
    "invalid": `(ugyldig)`,
    "loading": `Laster inn ...`,
    "noResults": `Ingen resultater`,
    "buttonLabel": `Vis forslag`,
    "listboxLabel": `Forslag`
  },
  "nl-NL": {
    "clear": `Helder`,
    "invalid": `(ongeldig)`,
    "loading": `Laden...`,
    "noResults": `Geen resultaten`,
    "buttonLabel": `Suggesties weergeven`,
    "listboxLabel": `Suggesties`
  },
  "pl-PL": {
    "clear": `Wyczyść`,
    "invalid": `(nieprawidłowy)`,
    "loading": `Trwa ładowanie...`,
    "noResults": `Brak wyników`,
    "buttonLabel": `Wyświetlaj sugestie`,
    "listboxLabel": `Sugestie`
  },
  "pt-BR": {
    "clear": `Limpar`,
    "invalid": `(inválido)`,
    "loading": `Carregando...`,
    "noResults": `Nenhum resultado`,
    "buttonLabel": `Mostrar sugestões`,
    "listboxLabel": `Sugestões`
  },
  "pt-PT": {
    "clear": `Limpar`,
    "invalid": `(inválido)`,
    "loading": `A carregar...`,
    "noResults": `Sem resultados`,
    "buttonLabel": `Apresentar sugestões`,
    "listboxLabel": `Sugestões`
  },
  "ro-RO": {
    "clear": `Golire`,
    "invalid": `(nevalid)`,
    "loading": `Se încarcă...`,
    "noResults": `Niciun rezultat`,
    "buttonLabel": `Afișare sugestii`,
    "listboxLabel": `Sugestii`
  },
  "ru-RU": {
    "clear": `Очистить`,
    "invalid": `(недействительно)`,
    "loading": `Загрузка...`,
    "noResults": `Результаты отсутствуют`,
    "buttonLabel": `Показать предложения`,
    "listboxLabel": `Предложения`
  },
  "sk-SK": {
    "clear": `Vymazať`,
    "invalid": `(neplatné)`,
    "loading": `Načítava sa...`,
    "noResults": `Žiadne výsledky`,
    "buttonLabel": `Zobraziť návrhy`,
    "listboxLabel": `Návrhy`
  },
  "sl-SI": {
    "clear": `Jasen`,
    "invalid": `(neveljavno)`,
    "loading": `Nalaganje...`,
    "noResults": `Ni rezultatov`,
    "buttonLabel": `Prikaži predloge`,
    "listboxLabel": `Predlogi`
  },
  "sr-SP": {
    "clear": `Izbriši`,
    "invalid": `(nevažeće)`,
    "loading": `Učitavam...`,
    "noResults": `Nema rezultata`,
    "buttonLabel": `Prikaži predloge`,
    "listboxLabel": `Predlozi`
  },
  "sv-SE": {
    "clear": `Rensa`,
    "invalid": `(ogiltigt)`,
    "loading": `Läser in...`,
    "noResults": `Inga resultat`,
    "buttonLabel": `Visa förslag`,
    "listboxLabel": `Förslag`
  },
  "tr-TR": {
    "clear": `Temizle`,
    "invalid": `(geçersiz)`,
    "loading": `Yükleniyor...`,
    "noResults": `Sonuç yok`,
    "buttonLabel": `Önerileri göster`,
    "listboxLabel": `Öneriler`
  },
  "uk-UA": {
    "clear": `Очистити`,
    "invalid": `(недійсне)`,
    "loading": `Завантаження...`,
    "noResults": `Результатів немає`,
    "buttonLabel": `Показати пропозиції`,
    "listboxLabel": `Пропозиції`
  },
  "zh-CN": {
    "clear": `透明`,
    "invalid": `（无效）`,
    "loading": `正在加载...`,
    "noResults": `无结果`,
    "buttonLabel": `显示建议`,
    "listboxLabel": `建议`
  },
  "zh-TW": {
    "clear": `清除`,
    "invalid": `(無效)`,
    "loading": `正在載入...`,
    "noResults": `無任何結果`,
    "buttonLabel": `顯示建議`,
    "listboxLabel": `建議`
  }
};

function MobileCombobox(_props, forwardedRef) {
  const props = useProviderProps(_props);
  let {
    isDisabled,
    validationState,
    isReadOnly
  } = props;
  let {
    contains
  } = useFilter({
    sensitivity: 'base'
  });
  let state = useComboBoxState({
    ...props,
    defaultFilter: contains,
    allowsEmptyCollection: true,
    // Needs to be false here otherwise we double up on
    // commitSelection/commitCustomValue calls when user taps on underlay (i.e.
    // initial tap will call setFocused(false) ->
    // commitSelection/commitCustomValue via onBlur, then the closing of the
    // tray will call setFocused(false) again due to cleanup effect)
    shouldCloseOnBlur: false
  });
  let buttonRef = useRef(null);
  let domRef = useObjectRef(forwardedRef);
  let {
    triggerProps,
    overlayProps
  } = useOverlayTrigger({
    type: 'listbox'
  }, state, buttonRef);
  let {
    labelProps,
    fieldProps
  } = useField({
    ...props,
    labelElementType: 'span'
  });

  // Focus the button and show focus ring when clicking on the label
  labelProps = {
    ...labelProps,
    onClick: () => {
      let button = buttonRef.current;
      if (button && !props.isDisabled) {
        button.focus();
        setInteractionModality('keyboard');
      }
    }
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(FieldPrimitive, {
      ...props,
      labelProps: labelProps
      // elementType="span"
      ,
      ref: domRef,
      supplementRequiredState: true,
      children: /*#__PURE__*/jsx(ComboboxButton$1, {
        ...mergeProps(triggerProps, fieldProps, {
          autoFocus: props.autoFocus
        }),
        ref: buttonRef,
        isDisabled: isDisabled,
        isReadOnly: isReadOnly,
        isPlaceholder: !state.inputValue,
        validationState: validationState,
        onPress: () => !isReadOnly && state.open(null, 'manual'),
        children: state.inputValue || props.placeholder || ''
      })
    }), /*#__PURE__*/jsx(Tray, {
      state: state,
      isFixedHeight: true,
      ...overlayProps,
      children: /*#__PURE__*/jsx(ComboboxTray$1, {
        ...props,
        onClose: state.close,
        overlayProps: overlayProps,
        state: state
      })
    })]
  });
}
const ComboboxButton$1 = /*#__PURE__*/React.forwardRef(function ComboboxButton(props, forwardedRef) {
  let {
    isDisabled,
    isPlaceholder,
    validationState,
    children,
    style
  } = props;
  let valueId = useId();
  let invalidId = useId();
  let domRef = useObjectRef(forwardedRef);
  let {
    hoverProps,
    isHovered
  } = useHover({});
  let {
    buttonProps,
    isPressed
  } = useButton({
    ...props,
    'aria-labelledby': [props['aria-labelledby'], props['aria-label'] && !props['aria-labelledby'] ? props.id : null, valueId, validationState === 'invalid' ? invalidId : null].filter(Boolean).join(' '),
    elementType: 'div'
  }, domRef);
  return /*#__PURE__*/jsx(FocusRing, {
    children: /*#__PURE__*/jsxs(Flex, {
      position: "relative",
      width: "alias.singleLineWidth",
      zIndex: 0 // create a new stacking context
      ,
      ...toDataAttributes({
        readonly: props.isReadOnly
      }),
      ...mergeProps(hoverProps, buttonProps),
      "aria-haspopup": "dialog",
      ref: domRef,
      UNSAFE_className: comboboxClassList.element('mobile-trigger'),
      UNSAFE_style: {
        ...style,
        outline: 'none'
      },
      children: [/*#__PURE__*/jsx(Flex, {
        alignItems: "center",
        paddingX: "medium",
        flex: true,
        children: /*#__PURE__*/jsx(Text, {
          id: valueId,
          color: isPlaceholder ? 'neutralSecondary' : undefined,
          trim: false,
          truncate: true,
          children: children
        })
      }), /*#__PURE__*/jsx(InputStateIndicator$1, {
        isHovered: isHovered,
        isPressed: isPressed,
        isDisabled: isDisabled,
        validationState: validationState
      }), /*#__PURE__*/jsx(CosmeticFieldButton$1, {
        isHovered: isHovered,
        isPressed: isPressed,
        isDisabled: isDisabled,
        validationState: validationState,
        UNSAFE_className: css({
          borderEndStartRadius: 0,
          borderStartStartRadius: 0,
          [`${comboboxClassList.selector('mobile-trigger')}[data-focus] &`]: {
            borderColor: tokenSchema.color.alias.borderFocused
          }
        }),
        children: /*#__PURE__*/jsx(Icon, {
          src: chevronDownIcon
        })
      })]
    })
  });
});
const CosmeticFieldButton$1 = props => {
  let {
    isHovered,
    isPressed,
    ...otherProps
  } = props;
  let {
    children,
    styleProps
  } = useFieldButton(otherProps, {
    isHovered,
    isPressed
  });
  return /*#__PURE__*/jsx("div", {
    "data-disabled": props.isDisabled,
    ...styleProps,
    children: children
  });
};
const InputStateIndicator$1 = props => {
  let {
    isDisabled,
    isHovered,
    isPressed
  } = props;
  return /*#__PURE__*/jsx("div", {
    role: "presentation",
    ...toDataAttributes({
      disabled: isDisabled,
      interaction: isPressed ? 'press' : isHovered ? 'hover' : undefined,
      validation: props.validationState
    }),
    className: css({
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
      borderRadius: tokenSchema.size.radius.regular,
      inset: 0,
      position: 'absolute',
      transition: transition(['border-color', 'box-shadow']),
      zIndex: -1,
      '&[data-interaction=hover]': {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      '&[data-validation=invalid]': {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [`${comboboxClassList.selector('mobile-trigger')}[data-focus] &`]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [`${comboboxClassList.selector('mobile-trigger')}[data-focus]:not([data-readonly]) &`]: {
        boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
      },
      '&[data-disabled=true]': {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        borderColor: 'transparent'
      }
    })
  });
};
function ComboboxTray$1(props) {
  let {
    state,
    isDisabled,
    validationState,
    label,
    overlayProps,
    loadingState,
    onLoadMore,
    onClose
  } = props;
  let timeoutRef = useRef(undefined);
  let [showLoading, setShowLoading] = useState(false);
  let inputRef = useRef(null);
  let buttonRef = useRef(null);
  let popoverRef = useRef(null);
  let listBoxRef = useRef(null);
  let layout = useListBoxLayout();
  let stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let {
    inputProps,
    listBoxProps,
    labelProps
  } = useComboBox({
    ...props,
    layoutDelegate: layout,
    buttonRef,
    popoverRef,
    listBoxRef,
    inputRef
  }, state);
  React.useEffect(() => {
    let input = inputRef.current;
    if (input) {
      focusSafely(input);
    }

    // When the tray unmounts, set state.isFocused (i.e. the tray input's focus tracker) to false.
    // This is to prevent state.isFocused from being set to true when the tray closes via tapping on the underlay
    // (FocusScope attempts to restore focus to the tray input when tapping outside the tray due to "contain")
    // Have to do this manually since React doesn't call onBlur when a component is unmounted: https://github.com/facebook/react/issues/12363
    return () => {
      state.setFocused(false);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  let {
    dialogProps
  } = useDialog({
    'aria-labelledby': useId(labelProps.id)
  }, popoverRef);

  // Override the role of the input to "searchbox" instead of "combobox".
  // Since the listbox is always visible, the combobox role doesn't really give us anything.
  // VoiceOver on iOS reads "double tap to collapse" when focused on the input rather than
  // "double tap to edit text", as with a textbox or searchbox. We'd like double tapping to
  // open the virtual keyboard rather than closing the tray.
  inputProps.role = 'searchbox';
  inputProps['aria-haspopup'] = 'listbox';
  delete inputProps.onTouchEnd;
  let clearButton = /*#__PURE__*/jsx(ClearButton, {
    preventFocus: true,
    "aria-label": stringFormatter.format('clear'),
    excludeFromTabOrder: true,
    onPress: () => {
      state.setInputValue('');
      let input_0 = inputRef.current;
      if (input_0) {
        input_0.focus();
      }
    },
    isDisabled: isDisabled
  });
  let loadingCircle = /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: /*#__PURE__*/jsx(ProgressCircle, {
      "aria-label": stringFormatter.format('loading'),
      size: "small",
      isIndeterminate: true
    })
  });

  // Close the software keyboard on scroll to give the user a bigger area to scroll.
  // But only do this if scrolling with touch, otherwise it can cause issues with touch
  // screen readers.
  let isTouchDown = useRef(false);
  let onTouchStart = () => {
    isTouchDown.current = true;
  };
  let onTouchEnd = () => {
    isTouchDown.current = false;
  };
  let onScroll = useCallback(() => {
    let input_1 = inputRef.current;
    let popover = popoverRef.current;
    if (!input_1 || document.activeElement !== input_1 || !isTouchDown.current) {
      return;
    }
    if (popover) {
      popover.focus();
    }
  }, [inputRef, popoverRef, isTouchDown]);
  let inputValue = inputProps.value;
  let lastInputValue = useRef(inputValue);
  useEffect(() => {
    if (loadingState === 'filtering' && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }

      // If user is typing, clear the timer and restart since it is a new request
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (loadingState !== 'filtering') {
      // If loading is no longer happening, clear any timers and hide the loading circle
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = undefined;
    }
    lastInputValue.current = inputValue;
  }, [loadingState, inputValue, showLoading]);
  let onKeyDown = e => {
    let popover_0 = popoverRef.current;
    // Close virtual keyboard if user hits Enter w/o any focused options
    if (popover_0 && e.key === 'Enter' && state.selectionManager.focusedKey == null) {
      popover_0.focus();
    } else {
      var _inputProps$onKeyDown;
      (_inputProps$onKeyDown = inputProps.onKeyDown) === null || _inputProps$onKeyDown === void 0 || _inputProps$onKeyDown.call(inputProps, e);
    }
  };
  return /*#__PURE__*/jsx(FocusScope, {
    restoreFocus: true,
    contain: true,
    children: /*#__PURE__*/jsxs(Flex, {
      direction: "column",
      height: "100%",
      ref: popoverRef,
      ...mergeProps(overlayProps, dialogProps),
      children: [/*#__PURE__*/jsx(DismissButton, {
        onDismiss: onClose
      }), /*#__PURE__*/jsx(TextFieldPrimitive, {
        label: label,
        labelProps: labelProps,
        inputProps: {
          ...inputProps,
          onKeyDown
        },
        ref: inputRef,
        isDisabled: isDisabled,
        marginX: "small",
        marginTop: "regular",
        endElement: /*#__PURE__*/jsxs(Flex, {
          children: [showLoading && loadingState === 'filtering' && loadingCircle, (state.inputValue !== '' || loadingState === 'filtering' || validationState != null) && !props.isReadOnly && clearButton]
        })
      }), /*#__PURE__*/jsx(ListBoxBase, {
        ...listBoxProps,
        domProps: {
          onTouchStart,
          onTouchEnd
        },
        disallowEmptySelection: true,
        shouldSelectOnPressUp: true,
        focusOnPointerEnter: true,
        layout: layout,
        state: state,
        shouldUseVirtualFocus: true,
        renderEmptyState: () => loadingState !== 'loading' && /*#__PURE__*/jsx(Flex, {
          height: "element.regular",
          alignItems: "center",
          paddingX: "medium",
          children: /*#__PURE__*/jsx(Text, {
            color: "neutralSecondary",
            children: stringFormatter.format('noResults')
          })
        }),
        ref: listBoxRef,
        onScroll: onScroll,
        onLoadMore: onLoadMore,
        isLoading: loadingState === 'loading' || loadingState === 'loadingMore'
      }), /*#__PURE__*/jsx(DismissButton, {
        onDismiss: onClose
      })]
    })
  });
}
const _MobileCombobox = /*#__PURE__*/React.forwardRef(MobileCombobox);

function Combobox(props, forwardedRef) {
  const $ = c(8);
  props = useProviderProps(props);
  const t0 = props;
  let t1;
  if ($[0] !== t0) {
    t1 = validateTextFieldProps(t0);
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  props = t1;
  const isMobile = useIsMobileDevice();
  if (isMobile) {
    let t2;
    if ($[2] !== props || $[3] !== forwardedRef) {
      t2 = /*#__PURE__*/jsx(_MobileCombobox, {
        ...props,
        menuTrigger: "input",
        ref: forwardedRef
      });
      $[2] = props;
      $[3] = forwardedRef;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    return t2;
  } else {
    let t2;
    if ($[5] !== props || $[6] !== forwardedRef) {
      t2 = /*#__PURE__*/jsx(ComboboxBase, {
        ...props,
        ref: forwardedRef
      });
      $[5] = props;
      $[6] = forwardedRef;
      $[7] = t2;
    } else {
      t2 = $[7];
    }
    return t2;
  }
}
const ComboboxBase = /*#__PURE__*/React.forwardRef(function ComboboxBase(props, forwardedRef) {
  var _state$focusStrategy;
  const $ = c(57);
  const {
    align: t0,
    menuTrigger: t1,
    shouldFlip: t2,
    direction: t3,
    loadingState,
    menuWidth,
    onLoadMore
  } = props;
  const align = t0 === undefined ? "start" : t0;
  const menuTrigger = t1 === undefined ? "input" : t1;
  const shouldFlip = t2 === undefined ? true : t2;
  const direction = t3 === undefined ? "bottom" : t3;
  const isAsync = loadingState != null;
  const buttonRef = useRef(null);
  const inputRef = useRef(null);
  const listBoxRef = useRef(null);
  const [popoverRefLikeValue, popoverRef] = useStatefulRef();
  const fieldRef = useObjectRef(forwardedRef);
  let t4;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      sensitivity: "base"
    };
    $[0] = t4;
  } else {
    t4 = $[0];
  }
  const {
    contains
  } = useFilter(t4);
  let t5;
  if ($[1] !== props || $[2] !== contains || $[3] !== isAsync) {
    t5 = {
      ...props,
      defaultFilter: contains,
      allowsEmptyCollection: isAsync
    };
    $[1] = props;
    $[2] = contains;
    $[3] = isAsync;
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  const state = useComboBoxState(t5);
  const layout = useListBoxLayout();
  let t6;
  if ($[5] !== props || $[6] !== layout || $[7] !== buttonRef || $[8] !== popoverRefLikeValue || $[9] !== listBoxRef || $[10] !== inputRef || $[11] !== menuTrigger) {
    t6 = {
      ...props,
      layoutDelegate: layout,
      buttonRef,
      popoverRef: popoverRefLikeValue,
      listBoxRef,
      inputRef,
      menuTrigger
    };
    $[5] = props;
    $[6] = layout;
    $[7] = buttonRef;
    $[8] = popoverRefLikeValue;
    $[9] = listBoxRef;
    $[10] = inputRef;
    $[11] = menuTrigger;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  const {
    buttonProps,
    inputProps,
    listBoxProps,
    labelProps,
    descriptionProps,
    errorMessageProps
  } = useComboBox(t6, state);
  let t7;
  if ($[13] !== menuWidth || $[14] !== buttonRef || $[15] !== inputRef || $[16] !== fieldRef) {
    t7 = {
      menuWidth,
      buttonRef,
      inputRef,
      fieldRef
    };
    $[13] = menuWidth;
    $[14] = buttonRef;
    $[15] = inputRef;
    $[16] = fieldRef;
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  const popoverStyle = usePopoverStyles(t7);
  let t8;
  if ($[18] !== props || $[19] !== state.isOpen || $[20] !== loadingState || $[21] !== inputProps || $[22] !== inputRef || $[23] !== buttonProps || $[24] !== buttonRef) {
    t8 = /*#__PURE__*/jsx(ComboboxInput, {
      ...props,
      isOpen: state.isOpen,
      loadingState: loadingState,
      inputProps: inputProps,
      inputRef: inputRef,
      triggerProps: buttonProps,
      triggerRef: buttonRef
    });
    $[18] = props;
    $[19] = state.isOpen;
    $[20] = loadingState;
    $[21] = inputProps;
    $[22] = inputRef;
    $[23] = buttonProps;
    $[24] = buttonRef;
    $[25] = t8;
  } else {
    t8 = $[25];
  }
  let t9;
  if ($[26] !== props || $[27] !== descriptionProps || $[28] !== errorMessageProps || $[29] !== labelProps || $[30] !== fieldRef || $[31] !== t8) {
    t9 = /*#__PURE__*/jsx(FieldPrimitive, {
      width: "alias.singleLineWidth",
      ...props,
      descriptionProps: descriptionProps,
      errorMessageProps: errorMessageProps,
      labelProps: labelProps,
      ref: fieldRef,
      children: t8
    });
    $[26] = props;
    $[27] = descriptionProps;
    $[28] = errorMessageProps;
    $[29] = labelProps;
    $[30] = fieldRef;
    $[31] = t8;
    $[32] = t9;
  } else {
    t9 = $[32];
  }
  const t10 = align === "end" ? buttonRef : inputRef;
  const t11 = `${direction} ${align}`;
  const t12 = (_state$focusStrategy = state.focusStrategy) !== null && _state$focusStrategy !== void 0 ? _state$focusStrategy : undefined;
  const t13 = loadingState === "loadingMore";
  let t14;
  if ($[33] !== isAsync || $[34] !== loadingState) {
    t14 = () => isAsync && /*#__PURE__*/jsx(ComboboxEmptyState, {
      loadingState: loadingState
    });
    $[33] = isAsync;
    $[34] = loadingState;
    $[35] = t14;
  } else {
    t14 = $[35];
  }
  let t15;
  if ($[36] !== listBoxProps || $[37] !== listBoxRef || $[38] !== t12 || $[39] !== layout || $[40] !== state || $[41] !== t13 || $[42] !== onLoadMore || $[43] !== t14) {
    t15 = /*#__PURE__*/jsx(ListBoxBase, {
      ...listBoxProps,
      ref: listBoxRef,
      disallowEmptySelection: true,
      autoFocus: t12,
      shouldSelectOnPressUp: true,
      focusOnPointerEnter: true,
      layout: layout,
      state: state,
      shouldUseVirtualFocus: true,
      isLoading: t13,
      onLoadMore: onLoadMore,
      UNSAFE_className: listStyles,
      renderEmptyState: t14
    });
    $[36] = listBoxProps;
    $[37] = listBoxRef;
    $[38] = t12;
    $[39] = layout;
    $[40] = state;
    $[41] = t13;
    $[42] = onLoadMore;
    $[43] = t14;
    $[44] = t15;
  } else {
    t15 = $[44];
  }
  let t16;
  if ($[45] !== state || $[46] !== popoverStyle || $[47] !== popoverRef || $[48] !== t10 || $[49] !== listBoxRef || $[50] !== t11 || $[51] !== shouldFlip || $[52] !== t15) {
    t16 = /*#__PURE__*/jsx(Popover, {
      state: state,
      UNSAFE_style: popoverStyle,
      ref: popoverRef,
      triggerRef: t10,
      scrollRef: listBoxRef,
      placement: t11,
      hideArrow: true,
      isNonModal: true,
      shouldFlip: shouldFlip,
      children: t15
    });
    $[45] = state;
    $[46] = popoverStyle;
    $[47] = popoverRef;
    $[48] = t10;
    $[49] = listBoxRef;
    $[50] = t11;
    $[51] = shouldFlip;
    $[52] = t15;
    $[53] = t16;
  } else {
    t16 = $[53];
  }
  let t17;
  if ($[54] !== t9 || $[55] !== t16) {
    t17 = /*#__PURE__*/jsxs(Fragment, {
      children: [t9, t16]
    });
    $[54] = t9;
    $[55] = t16;
    $[56] = t17;
  } else {
    t17 = $[56];
  }
  return t17;
});
function ComboboxEmptyState(props) {
  const $ = c(5);
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let t0;
  if ($[0] !== props.loadingState || $[1] !== stringFormatter) {
    t0 = props.loadingState === "loading" ? stringFormatter.format("loading") : stringFormatter.format("noResults");
    $[0] = props.loadingState;
    $[1] = stringFormatter;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] !== t0) {
    t1 = /*#__PURE__*/jsx(Flex, {
      height: "element.regular",
      alignItems: "center",
      paddingX: "medium",
      children: /*#__PURE__*/jsx(Text, {
        color: "neutralSecondary",
        children: t0
      })
    });
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}
function usePopoverStyles(props) {
  const {
    buttonRef,
    inputRef,
    fieldRef,
    menuWidth: menuWidthProp
  } = props;

  // Measure the width of the input and the button to inform the width of the menu (below).
  let [menuWidth, setMenuWidth] = useState();
  let onResize = useCallback(() => {
    if (buttonRef.current && inputRef.current) {
      let buttonWidth = buttonRef.current.offsetWidth;
      let inputWidth = inputRef.current.offsetWidth;
      setMenuWidth(inputWidth + buttonWidth);
    }
  }, [buttonRef, inputRef, setMenuWidth]);
  useResizeObserver({
    ref: fieldRef,
    onResize: onResize
  });
  useLayoutEffect(onResize, [onResize]);
  return {
    width: menuWidth,
    minWidth: menuWidthProp !== null && menuWidthProp !== void 0 ? menuWidthProp : menuWidth
  };
}

// FIXME: this is a hack to work around a requirement of react-aria. object refs
// never have the value early enough, so we need to use a stateful ref to force
// a re-render.
function useStatefulRef() {
  const $ = c(2);
  const [current, statefulRef] = useState(null);
  let t0;
  let t1;
  if ($[0] !== current) {
    t1 = [{
      current
    }, statefulRef];
    $[0] = current;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  return t0;
}
/** @private Used by multi variant. */
const ComboboxInput = /*#__PURE__*/React.forwardRef(function ComboboxInput(props, forwardedRef) {
  let {
    isDisabled,
    inputProps,
    inputRef,
    triggerProps,
    triggerRef,
    autoFocus,
    style,
    loadingState,
    isOpen,
    menuTrigger
  } = props;
  let stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let timeoutRef = useRef(undefined);
  let [showLoading, setShowLoading] = useState(false);
  let loadingCircle = /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: /*#__PURE__*/jsx(ProgressCircle, {
      "aria-label": stringFormatter.format('loading'),
      size: "small",
      isIndeterminate: true
    })
  });
  let isLoading = loadingState === 'loading' || loadingState === 'filtering';
  let inputValue = inputProps.value;
  let lastInputValue = useRef(inputValue);
  useEffect(() => {
    if (isLoading && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }

      // If user is typing, clear the timer and restart since it is a new request
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (!isLoading) {
      // If loading is no longer happening, clear any timers and hide the loading circle
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = undefined;
    }
    lastInputValue.current = inputValue;
  }, [isLoading, showLoading, inputValue]);
  return /*#__PURE__*/jsx(FocusRing, {
    autoFocus: autoFocus,
    isTextInput: true,
    within: true,
    children: /*#__PURE__*/jsx("div", {
      ref: forwardedRef,
      style: style,
      children: /*#__PURE__*/jsx(TextFieldPrimitive, {
        inputProps: {
          ...inputProps,
          className: comboboxClassList.element('input')
        },
        ref: inputRef,
        isDisabled: isDisabled
        // loading circle should only be displayed if menu is open, if
        // menuTrigger is "manual", or first time load (to stop circle from
        // showing up when user selects an option)
        // startElement={
        //   showLoading &&
        //   (isOpen || menuTrigger === 'manual' || loadingState === 'loading')
        //     ? loadingState != null && loadingCircle
        //     : null
        // }
        ,
        endElement: /*#__PURE__*/jsxs(Fragment, {
          children: [showLoading && (isOpen || menuTrigger === 'manual' || loadingState === 'loading') ? loadingCircle : null, /*#__PURE__*/jsx(PressResponder, {
            preventFocusOnPress: true,
            isPressed: isOpen,
            children: /*#__PURE__*/jsx(FieldButton, {
              ...triggerProps,
              ref: triggerRef,
              UNSAFE_className: css({
                borderEndStartRadius: 0,
                borderStartStartRadius: 0,
                [`${comboboxClassList.selector('input')}[aria-invalid] ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderInvalid
                },
                [`${comboboxClassList.selector('input')}[readonly] ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderIdle
                },
                [`${comboboxClassList.selector('input')}:focus ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderFocused
                }
              }),
              children: /*#__PURE__*/jsx(Icon, {
                src: chevronDownIcon
              })
            })
          })]
        })
      })
    })
  });
});

/**
 * A combobox combines a text input with a listbox, and allows users to filter a
 * list of options.
 */
const _Combobox = /*#__PURE__*/React.forwardRef(Combobox);

function useComboboxMultiState(props) {
  var _props$items, _props$defaultInputVa;
  const $ = c(68);
  const {
    allowsEmptyCollection: t0,
    menuTrigger: t1
  } = props;
  const allowsEmptyCollection = t0 === undefined ? false : t0;
  const menuTrigger = t1 === undefined ? "input" : t1;
  const [showAllItems, setShowAllItems] = useState(false);
  const t2 = (_props$items = props.items) !== null && _props$items !== void 0 ? _props$items : props.defaultItems;
  let t3;
  if ($[0] !== props || $[1] !== t2) {
    t3 = {
      ...props,
      items: t2,
      selectionBehavior: "toggle",
      selectionMode: "multiple"
    };
    $[0] = props;
    $[1] = t2;
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  const listState = useListState(t3);
  let t4;
  if ($[3] !== props) {
    t4 = {
      ...props,
      onOpenChange: props.onOpenChange,
      isOpen: undefined,
      defaultOpen: undefined
    };
    $[3] = props;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  const triggerState = useMenuTriggerState(t4);
  const [inputValue, setInputValue] = useControlledState(props.inputValue, (_props$defaultInputVa = props.defaultInputValue) !== null && _props$defaultInputVa !== void 0 ? _props$defaultInputVa : "", props.onInputChange);
  const lastInputValue = usePrevious(inputValue);
  const {
    collection
  } = listState;
  const originalCollection = collection;
  let t5;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      sensitivity: "base"
    };
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  const {
    contains
  } = useFilter(t5);
  let t6;
  bb0: {
    if (props.items != null) {
      t6 = collection;
      break bb0;
    }
    let t7;
    if ($[6] !== collection || $[7] !== inputValue || $[8] !== contains) {
      t7 = filterCollection(collection, inputValue, contains);
      $[6] = collection;
      $[7] = inputValue;
      $[8] = contains;
      $[9] = t7;
    } else {
      t7 = $[9];
    }
    t6 = t7;
  }
  const filteredCollection = t6;
  const [lastCollection, setLastCollection] = useState(filteredCollection);
  let t7;
  if ($[10] !== showAllItems || $[11] !== originalCollection || $[12] !== filteredCollection) {
    t7 = () => {
      setLastCollection(showAllItems ? originalCollection : filteredCollection);
    };
    $[10] = showAllItems;
    $[11] = originalCollection;
    $[12] = filteredCollection;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  const updateLastCollection = t7;
  let t8;
  if ($[14] !== updateLastCollection || $[15] !== triggerState) {
    t8 = () => {
      updateLastCollection();
      triggerState.close();
    };
    $[14] = updateLastCollection;
    $[15] = triggerState;
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  const closeMenu = t8;
  let t9;
  if ($[17] !== setInputValue || $[18] !== closeMenu) {
    t9 = () => {
      setInputValue("");
      closeMenu();
    };
    $[17] = setInputValue;
    $[18] = closeMenu;
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  const close = t9;
  let t10;
  if ($[20] !== menuTrigger || $[21] !== allowsEmptyCollection || $[22] !== filteredCollection.size || $[23] !== originalCollection.size || $[24] !== props.items || $[25] !== triggerState) {
    t10 = t11 => {
      const focusStrategy = t11 === undefined ? null : t11;
      const displayAllItems = menuTrigger === "focus";
      if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {
        if (displayAllItems && !triggerState.isOpen && props.items === undefined) {
          setShowAllItems(true);
        }
        triggerState.open(focusStrategy);
      }
    };
    $[20] = menuTrigger;
    $[21] = allowsEmptyCollection;
    $[22] = filteredCollection.size;
    $[23] = originalCollection.size;
    $[24] = props.items;
    $[25] = triggerState;
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  const open = t10;
  let t11;
  if ($[27] !== menuTrigger || $[28] !== allowsEmptyCollection || $[29] !== filteredCollection.size || $[30] !== originalCollection.size || $[31] !== props.items || $[32] !== triggerState || $[33] !== updateLastCollection) {
    t11 = t12 => {
      const focusStrategy_0 = t12 === undefined ? null : t12;
      const displayAllItems_0 = menuTrigger === "focus";
      if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems_0 && originalCollection.size > 0 || props.items) && !triggerState.isOpen) {
        return;
      }
      if (displayAllItems_0 && !triggerState.isOpen && props.items === undefined) {
        setShowAllItems(true);
      }
      triggerState.toggle(focusStrategy_0);
      if (triggerState.isOpen) {
        updateLastCollection();
      }
    };
    $[27] = menuTrigger;
    $[28] = allowsEmptyCollection;
    $[29] = filteredCollection.size;
    $[30] = originalCollection.size;
    $[31] = props.items;
    $[32] = triggerState;
    $[33] = updateLastCollection;
    $[34] = t11;
  } else {
    t11 = $[34];
  }
  const toggle = t11;
  let t12;
  if ($[35] !== props.selectedKeys || $[36] !== props.inputValue || $[37] !== props.onSelectionChange || $[38] !== listState.selectionManager.selectedKeys || $[39] !== close) {
    t12 = () => {
      if (props.selectedKeys !== undefined && props.inputValue !== undefined) {
        var _props$onSelectionCha;
        (_props$onSelectionCha = props.onSelectionChange) === null || _props$onSelectionCha === void 0 || _props$onSelectionCha.call(props, listState.selectionManager.selectedKeys);
      }
      close();
    };
    $[35] = props.selectedKeys;
    $[36] = props.inputValue;
    $[37] = props.onSelectionChange;
    $[38] = listState.selectionManager.selectedKeys;
    $[39] = close;
    $[40] = t12;
  } else {
    t12 = $[40];
  }
  const commit = t12;
  let t13;
  if ($[41] !== triggerState || $[42] !== inputValue || $[43] !== lastInputValue || $[44] !== showAllItems || $[45] !== allowsEmptyCollection || $[46] !== filteredCollection.size || $[47] !== closeMenu) {
    t13 = () => {
      if (!triggerState.isOpen && inputValue && inputValue !== lastInputValue) {
        triggerState.open();
      }
      if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0) {
        closeMenu();
      }
    };
    $[41] = triggerState;
    $[42] = inputValue;
    $[43] = lastInputValue;
    $[44] = showAllItems;
    $[45] = allowsEmptyCollection;
    $[46] = filteredCollection.size;
    $[47] = closeMenu;
    $[48] = t13;
  } else {
    t13 = $[48];
  }
  useEffect(t13);
  let t14;
  let t15;
  if ($[49] !== inputValue || $[50] !== listState.selectionManager.selectedKeys) {
    t15 = {
      inputValue,
      selectedKeys: listState.selectionManager.selectedKeys
    };
    $[49] = inputValue;
    $[50] = listState.selectionManager.selectedKeys;
    $[51] = t15;
  } else {
    t15 = $[51];
  }
  t14 = t15;
  let t16;
  if ($[52] !== props || $[53] !== t14) {
    t16 = {
      ...props,
      value: t14
    };
    $[52] = props;
    $[53] = t14;
    $[54] = t16;
  } else {
    t16 = $[54];
  }
  const validation = useFormValidationState(t16);
  let t17;
  if (triggerState.isOpen) {
    if (showAllItems) {
      t17 = originalCollection;
    } else {
      t17 = filteredCollection;
    }
  } else {
    t17 = lastCollection;
  }
  const displayedCollection = t17;
  let t18;
  if ($[55] !== validation || $[56] !== triggerState.focusStrategy || $[57] !== triggerState.isOpen || $[58] !== triggerState.setOpen || $[59] !== toggle || $[60] !== open || $[61] !== commit || $[62] !== listState.selectionManager || $[63] !== listState.disabledKeys || $[64] !== displayedCollection || $[65] !== inputValue || $[66] !== setInputValue) {
    t18 = {
      ...validation,
      focusStrategy: triggerState.focusStrategy,
      isOpen: triggerState.isOpen,
      setOpen: triggerState.setOpen,
      toggle,
      open,
      close: commit,
      selectionManager: listState.selectionManager,
      disabledKeys: listState.disabledKeys,
      collection: displayedCollection,
      inputValue,
      setInputValue
    };
    $[55] = validation;
    $[56] = triggerState.focusStrategy;
    $[57] = triggerState.isOpen;
    $[58] = triggerState.setOpen;
    $[59] = toggle;
    $[60] = open;
    $[61] = commit;
    $[62] = listState.selectionManager;
    $[63] = listState.disabledKeys;
    $[64] = displayedCollection;
    $[65] = inputValue;
    $[66] = setInputValue;
    $[67] = t18;
  } else {
    t18 = $[67];
  }
  return t18;
}
function filterCollection(collection, inputValue, filter) {
  return new ListCollection(filterNodes(collection, collection, inputValue, filter));
}
function filterNodes(collection, nodes, inputValue, filter) {
  let filteredNode = [];
  for (let node of nodes) {
    if (node.type === 'section' && node.hasChildNodes) {
      let filtered = filterNodes(collection, getChildNodes(node, collection), inputValue, filter);
      if ([...filtered].some(node => node.type === 'item')) {
        filteredNode.push({
          ...node,
          childNodes: filtered
        });
      }
    } else if (node.type === 'item' && filter(node.textValue, inputValue)) {
      filteredNode.push({
        ...node
      });
    } else if (node.type !== 'item') {
      filteredNode.push({
        ...node
      });
    }
  }
  return filteredNode;
}

function useComboboxMulti(props, state) {
  let {
    isDisabled,
    isReadOnly,
    menuTrigger = 'input',
    buttonRef: buttonRefProp,
    inputRef,
    keyboardDelegate,
    layoutDelegate,
    listBoxRef,
    popoverRef,
    shouldCloseOnBlur = true
  } = props;

  // combobox doesn't require a button element, so we need a backup ref for the
  // menu trigger hook
  let backupBtnRef = useRef(null);
  let buttonRef = buttonRefProp !== null && buttonRefProp !== void 0 ? buttonRefProp : backupBtnRef;
  let {
    menuTriggerProps,
    menuProps
  } = useMenuTrigger({
    type: 'listbox',
    isDisabled: isDisabled || isReadOnly
  }, state, buttonRef);

  // Set listbox id so it can be used when calling getItemId later
  listData.set(state, {
    id: menuProps.id
  });
  let stringFormatter = useLocalizedStringFormatter(localizedMessages);

  // By default, a KeyboardDelegate is provided which uses the DOM to query
  // layout information (e.g. for page up/page down). When virtualized, the
  // layout object will be passed in as a prop and override this.
  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate({
    collection: state.collection,
    disabledKeys: state.selectionManager.disabledKeys,
    ref: listBoxRef,
    layoutDelegate
  }), [keyboardDelegate, layoutDelegate, state.collection, state.selectionManager.disabledKeys, listBoxRef]);

  // Use useSelectableCollection to get the keyboard handlers to apply to the textfield
  let {
    collectionProps
  } = useSelectableCollection({
    selectionManager: state.selectionManager,
    keyboardDelegate: delegate,
    disallowTypeAhead: true,
    disallowEmptySelection: true,
    shouldFocusWrap: true,
    ref: inputRef,
    // This would be nice but it'd have to work with the _filtered_ collection
    disallowSelectAll: true,
    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component
    isVirtualized: true
  });
  useEffect(() => {
    if (state.isOpen) {
      return ariaHideOutside([inputRef.current, popoverRef.current].filter(element => element != null));
    }
  }, [state.isOpen, inputRef, popoverRef]);

  // TextField
  // ---------------------------------------------------------------------------

  let onKeyDown = e => {
    // Ignore composition events for CJK input
    if (e.nativeEvent.isComposing) {
      return;
    }
    switch (e.key) {
      case 'Enter':
        // Prevent form submission when open, assume the intent is selection
        if (state.isOpen) {
          e.preventDefault();
        }
        if (state.selectionManager.focusedKey) {
          state.selectionManager.select(state.selectionManager.focusedKey);
        }

        // Clear the input value after selection but keep the menu open
        state.setInputValue('');
        break;
      case 'Escape':
        // Propagate the event when closed, assume the intent is to dismiss a
        // parental the dialog
        if (!state.isOpen) {
          e.continuePropagation();
        }
        state.close();
        break;
      case 'ArrowDown':
        state.open('first');
        break;
      case 'ArrowUp':
        state.open('last');
        break;
      case 'ArrowLeft':
      case 'ArrowRight':
        state.selectionManager.setFocusedKey(null);
        break;
    }
  };
  let onBlur = e_0 => {
    var _props$onBlur;
    (_props$onBlur = props.onBlur) === null || _props$onBlur === void 0 || _props$onBlur.call(props, e_0);
    if (shouldCloseOnBlur) {
      state.close();
    }
  };
  let onFocus = e_1 => {
    var _props$onFocus;
    (_props$onFocus = props.onFocus) === null || _props$onFocus === void 0 || _props$onFocus.call(props, e_1);
    if (menuTrigger === 'focus' && !props.isReadOnly) {
      state.open();
    }
    state.selectionManager.setFocused(true);
  };
  let {
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  } = useTextField({
    ...props,
    onBlur,
    onFocus,
    onChange: state.setInputValue,
    onKeyDown: !props.isReadOnly ? chain(state.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown) : props.onKeyDown,
    autoComplete: 'off',
    validate: undefined,
    value: state.inputValue
  }, inputRef);

  // Button
  // ---------------------------------------------------------------------------

  let onPress = e_2 => {
    if (e_2.pointerType === 'touch') {
      var _inputRef$current;
      // Focus the input field in case it isn't focused yet
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
      state.toggle();
    }
  };
  let onPressStart = e_3 => {
    if (e_3.pointerType !== 'touch') {
      var _inputRef$current2;
      (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.focus();
      let strategy = e_3.pointerType === 'keyboard' || e_3.pointerType === 'virtual' ? 'first' : null;
      state.toggle(strategy);
    }
  };

  // Misc.
  // ---------------------------------------------------------------------------

  let {
    isInvalid,
    validationErrors,
    validationDetails
  } = state.displayValidation;
  let focusedItem = state.selectionManager.focusedKey != null && state.isOpen ? state.collection.getItem(state.selectionManager.focusedKey) : undefined;
  let triggerLabelProps = useLabels({
    id: menuTriggerProps.id,
    'aria-label': stringFormatter.format('buttonLabel'),
    'aria-labelledby': props['aria-labelledby'] || labelProps.id
  });
  let listBoxProps = useLabels({
    id: menuProps.id,
    'aria-label': stringFormatter.format('listboxLabel'),
    'aria-labelledby': props['aria-labelledby'] || labelProps.id
  });
  return {
    buttonProps: {
      ...menuTriggerProps,
      ...triggerLabelProps,
      excludeFromTabOrder: true,
      isDisabled: props.isDisabled || props.isReadOnly,
      onPress,
      onPressStart
    },
    descriptionProps,
    errorMessageProps,
    inputProps: mergeProps(inputProps, {
      role: 'combobox',
      'aria-expanded': menuTriggerProps['aria-expanded'],
      'aria-controls': state.isOpen ? menuProps.id : undefined,
      'aria-autocomplete': 'list',
      'aria-activedescendant': focusedItem ? getItemId(state, focusedItem.key) : undefined,
      // onTouchEnd,
      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.
      autoCorrect: 'off',
      // This disable's the macOS Safari spell check auto corrections.
      spellCheck: 'false'
    }),
    listBoxProps: mergeProps(menuProps, listBoxProps, {
      // autoFocus: state.focusStrategy,
      shouldUseVirtualFocus: true,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      // layout: layoutDelegate,
      linkBehavior: 'selection'
    }),
    labelProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

function MobileComboboxMulti(_props, forwardedRef) {
  const props = useProviderProps(_props);
  let {
    isDisabled,
    isReadOnly,
    validationState
  } = props;

  // let { contains } = useFilter({ sensitivity: 'base' });
  let state = useComboboxMultiState({
    ...props,
    // defaultFilter: contains,
    allowsEmptyCollection: true
  });
  let buttonRef = useRef(null);
  let domRef = useObjectRef(forwardedRef);
  let {
    triggerProps,
    overlayProps
  } = useOverlayTrigger({
    type: 'listbox'
  }, state, buttonRef);
  let {
    labelProps,
    fieldProps
  } = useField({
    ...props,
    labelElementType: 'span'
  });

  // Focus the button and show focus ring when clicking on the label
  labelProps = {
    ...labelProps,
    onClick: () => {
      let button = buttonRef.current;
      if (button && !props.isDisabled) {
        button.focus();
        setInteractionModality('keyboard');
      }
    }
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(FieldPrimitive, {
      ...props,
      labelProps: labelProps
      // elementType="span"
      ,
      ref: domRef,
      supplementRequiredState: true,
      children: /*#__PURE__*/jsx(ComboboxButton, {
        ...mergeProps(triggerProps, fieldProps, {
          autoFocus: props.autoFocus
        }),
        ref: buttonRef,
        isDisabled: isDisabled,
        isReadOnly: isReadOnly,
        isPlaceholder: !state.inputValue,
        validationState: validationState,
        onPress: () => !isReadOnly && state.open(),
        children: state.inputValue || props.placeholder || ''
      })
    }), /*#__PURE__*/jsx(Tray, {
      state: state,
      isFixedHeight: true,
      ...overlayProps,
      children: /*#__PURE__*/jsx(ComboboxTray, {
        ...props,
        onClose: state.close,
        overlayProps: overlayProps,
        state: state
      })
    })]
  });
}
const ComboboxButton = /*#__PURE__*/React.forwardRef(function ComboboxButton(props, forwardedRef) {
  let {
    isDisabled,
    isPlaceholder,
    validationState,
    children,
    style
  } = props;
  let valueId = useId();
  let invalidId = useId();
  let domRef = useObjectRef(forwardedRef);
  let {
    hoverProps,
    isHovered
  } = useHover({});
  let {
    buttonProps,
    isPressed
  } = useButton({
    ...props,
    'aria-labelledby': [props['aria-labelledby'], props['aria-label'] && !props['aria-labelledby'] ? props.id : null, valueId, validationState === 'invalid' ? invalidId : null].filter(Boolean).join(' '),
    elementType: 'div'
  }, domRef);
  return /*#__PURE__*/jsx(FocusRing, {
    children: /*#__PURE__*/jsxs(Flex, {
      position: "relative",
      width: "alias.singleLineWidth",
      zIndex: 0 // create a new stacking context
      ,
      ...toDataAttributes({
        readonly: props.isReadOnly
      }),
      ...mergeProps(hoverProps, buttonProps),
      "aria-haspopup": "dialog",
      ref: domRef,
      UNSAFE_className: comboboxClassList.element('mobile-trigger'),
      UNSAFE_style: {
        ...style,
        outline: 'none'
      },
      children: [/*#__PURE__*/jsx(Flex, {
        alignItems: "center",
        paddingX: "medium",
        flex: true,
        children: /*#__PURE__*/jsx(Text, {
          id: valueId,
          color: isPlaceholder ? 'neutralSecondary' : undefined,
          trim: false,
          truncate: true,
          children: children
        })
      }), /*#__PURE__*/jsx(InputStateIndicator, {
        isHovered: isHovered,
        isPressed: isPressed,
        isDisabled: isDisabled,
        validationState: validationState
      }), /*#__PURE__*/jsx(CosmeticFieldButton, {
        isHovered: isHovered,
        isPressed: isPressed,
        isDisabled: isDisabled,
        validationState: validationState,
        UNSAFE_className: css({
          borderEndStartRadius: 0,
          borderStartStartRadius: 0,
          [`${comboboxClassList.selector('mobile-trigger')}[data-focus] &`]: {
            borderColor: tokenSchema.color.alias.borderFocused
          }
        }),
        children: /*#__PURE__*/jsx(Icon, {
          src: chevronDownIcon
        })
      })]
    })
  });
});
const CosmeticFieldButton = props => {
  let {
    isHovered,
    isPressed,
    ...otherProps
  } = props;
  let {
    children,
    styleProps
  } = useFieldButton(otherProps, {
    isHovered,
    isPressed
  });
  return /*#__PURE__*/jsx("div", {
    "data-disabled": props.isDisabled,
    ...styleProps,
    children: children
  });
};
const InputStateIndicator = props => {
  let {
    isDisabled,
    isHovered,
    isPressed
  } = props;
  return /*#__PURE__*/jsx("div", {
    role: "presentation",
    ...toDataAttributes({
      disabled: isDisabled,
      interaction: isPressed ? 'press' : isHovered ? 'hover' : undefined,
      validation: props.validationState
    }),
    className: css({
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
      borderRadius: tokenSchema.size.radius.regular,
      inset: 0,
      position: 'absolute',
      transition: transition(['border-color', 'box-shadow']),
      zIndex: -1,
      '&[data-interaction=hover]': {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      '&[data-validation=invalid]': {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [`${comboboxClassList.selector('mobile-trigger')}[data-focus] &`]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [`${comboboxClassList.selector('mobile-trigger')}[data-focus]:not([data-readonly]) &`]: {
        boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
      },
      '&[data-disabled=true]': {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        borderColor: 'transparent'
      }
    })
  });
};
function ComboboxTray(props) {
  let {
    state,
    isDisabled,
    validationState,
    label,
    overlayProps,
    loadingState,
    onLoadMore,
    onClose
  } = props;
  let timeoutRef = useRef(undefined);
  let [showLoading, setShowLoading] = useState(false);
  let inputRef = useRef(null);
  let buttonRef = useRef(null);
  let popoverRef = useRef(null);
  let listBoxRef = useRef(null);
  let layout = useListBoxLayout();
  let stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let {
    inputProps,
    listBoxProps,
    labelProps
  } = useComboboxMulti({
    ...props,
    layoutDelegate: layout,
    buttonRef,
    popoverRef,
    listBoxRef,
    inputRef,
    // fix for close on blur behaviour
    shouldCloseOnBlur: false
  }, state);
  React.useEffect(() => {
    let input = inputRef.current;
    if (input) {
      focusSafely(input);
    }

    // When the tray unmounts, set state.isFocused (i.e. the tray input's focus tracker) to false.
    // This is to prevent state.isFocused from being set to true when the tray closes via tapping on the underlay
    // (FocusScope attempts to restore focus to the tray input when tapping outside the tray due to "contain")
    // Have to do this manually since React doesn't call onBlur when a component is unmounted: https://github.com/facebook/react/issues/12363
    return () => {
      state.selectionManager.setFocusedKey(null);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  let {
    dialogProps
  } = useDialog({
    'aria-labelledby': useId(labelProps.id)
  }, popoverRef);

  // Override the role of the input to "searchbox" instead of "combobox".
  // Since the listbox is always visible, the combobox role doesn't really give us anything.
  // VoiceOver on iOS reads "double tap to collapse" when focused on the input rather than
  // "double tap to edit text", as with a textbox or searchbox. We'd like double tapping to
  // open the virtual keyboard rather than closing the tray.
  inputProps.role = 'searchbox';
  inputProps['aria-haspopup'] = 'listbox';
  delete inputProps.onTouchEnd;
  let clearButton = /*#__PURE__*/jsx(ClearButton, {
    preventFocus: true,
    "aria-label": stringFormatter.format('clear'),
    excludeFromTabOrder: true,
    onPress: () => {
      state.setInputValue('');
      let input_0 = inputRef.current;
      if (input_0) {
        input_0.focus();
      }
    },
    isDisabled: isDisabled
  });
  let loadingCircle = /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: /*#__PURE__*/jsx(ProgressCircle, {
      "aria-label": stringFormatter.format('loading'),
      size: "small",
      isIndeterminate: true
    })
  });

  // Close the software keyboard on scroll to give the user a bigger area to scroll.
  // But only do this if scrolling with touch, otherwise it can cause issues with touch
  // screen readers.
  let isTouchDown = useRef(false);
  let onTouchStart = () => {
    isTouchDown.current = true;
  };
  let onTouchEnd = () => {
    isTouchDown.current = false;
  };
  let onScroll = useCallback(() => {
    let input_1 = inputRef.current;
    let popover = popoverRef.current;
    if (!input_1 || document.activeElement !== input_1 || !isTouchDown.current) {
      return;
    }
    if (popover) {
      popover.focus();
    }
  }, [inputRef, popoverRef, isTouchDown]);
  let inputValue = inputProps.value;
  let lastInputValue = useRef(inputValue);
  useEffect(() => {
    if (loadingState === 'filtering' && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }

      // If user is typing, clear the timer and restart since it is a new request
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (loadingState !== 'filtering') {
      // If loading is no longer happening, clear any timers and hide the loading circle
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = undefined;
    }
    lastInputValue.current = inputValue;
  }, [loadingState, inputValue, showLoading]);
  let onKeyDown = e => {
    let popover_0 = popoverRef.current;
    // Close virtual keyboard if user hits Enter w/o any focused options
    if (popover_0 && e.key === 'Enter' && state.selectionManager.focusedKey == null) {
      popover_0.focus();
    } else {
      var _inputProps$onKeyDown;
      (_inputProps$onKeyDown = inputProps.onKeyDown) === null || _inputProps$onKeyDown === void 0 || _inputProps$onKeyDown.call(inputProps, e);
    }
  };
  return /*#__PURE__*/jsx(FocusScope, {
    restoreFocus: true,
    contain: true,
    children: /*#__PURE__*/jsxs(Flex, {
      direction: "column",
      height: "100%",
      ref: popoverRef,
      ...mergeProps(overlayProps, dialogProps),
      children: [/*#__PURE__*/jsx(DismissButton, {
        onDismiss: onClose
      }), /*#__PURE__*/jsx(TextFieldPrimitive, {
        label: label,
        labelProps: labelProps,
        inputProps: {
          ...inputProps,
          onKeyDown
        },
        ref: inputRef,
        isDisabled: isDisabled,
        marginX: "small",
        marginTop: "regular",
        endElement: /*#__PURE__*/jsxs(Flex, {
          children: [showLoading && loadingState === 'filtering' && loadingCircle, (state.inputValue !== '' || loadingState === 'filtering' || validationState != null) && !props.isReadOnly && clearButton]
        })
      }), /*#__PURE__*/jsx(ListBoxBase, {
        ...listBoxProps,
        domProps: {
          onTouchStart,
          onTouchEnd
        },
        disallowEmptySelection: true,
        shouldSelectOnPressUp: true,
        focusOnPointerEnter: true,
        layout: layout,
        state: state,
        shouldUseVirtualFocus: true,
        renderEmptyState: () => loadingState !== 'loading' && /*#__PURE__*/jsx(Flex, {
          height: "element.regular",
          alignItems: "center",
          paddingX: "medium",
          children: /*#__PURE__*/jsx(Text, {
            color: "neutralSecondary",
            children: stringFormatter.format('noResults')
          })
        }),
        ref: listBoxRef,
        onScroll: onScroll,
        onLoadMore: onLoadMore,
        isLoading: loadingState === 'loading' || loadingState === 'loadingMore'
      }), /*#__PURE__*/jsx(DismissButton, {
        onDismiss: onClose
      })]
    })
  });
}
const _MobileComboboxMulti = /*#__PURE__*/React.forwardRef(MobileComboboxMulti);

function ComboboxMulti(props, forwardedRef) {
  const $ = c(8);
  props = useProviderProps(props);
  const t0 = props;
  let t1;
  if ($[0] !== t0) {
    t1 = validateTextFieldProps(t0);
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  props = t1;
  const isMobile = useIsMobileDevice();
  if (isMobile) {
    let t2;
    if ($[2] !== props || $[3] !== forwardedRef) {
      t2 = /*#__PURE__*/jsx(_MobileComboboxMulti, {
        ...props,
        menuTrigger: "input",
        ref: forwardedRef
      });
      $[2] = props;
      $[3] = forwardedRef;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    return t2;
  } else {
    let t2;
    if ($[5] !== props || $[6] !== forwardedRef) {
      t2 = /*#__PURE__*/jsx(ComboboxMultiBase, {
        ...props,
        ref: forwardedRef
      });
      $[5] = props;
      $[6] = forwardedRef;
      $[7] = t2;
    } else {
      t2 = $[7];
    }
    return t2;
  }
}
const ComboboxMultiBase = /*#__PURE__*/React.forwardRef(function ComboboxMultiBase(props, forwardedRef) {
  var _state$focusStrategy;
  const $ = c(51);
  const {
    align: t0,
    shouldFlip: t1,
    direction: t2,
    loadingState,
    menuWidth,
    onLoadMore
  } = props;
  const align = t0 === undefined ? "start" : t0;
  const shouldFlip = t1 === undefined ? true : t1;
  const direction = t2 === undefined ? "bottom" : t2;
  const isAsync = loadingState != null;
  const buttonRef = useRef(null);
  const inputRef = useRef(null);
  const listBoxRef = useRef(null);
  const [popoverRefLikeValue, popoverRef] = useStatefulRef();
  const fieldRef = useObjectRef(forwardedRef);
  const layoutDelegate = useListBoxLayout();
  const state = useComboboxMultiState(props);
  let t3;
  if ($[0] !== props || $[1] !== buttonRef || $[2] !== inputRef || $[3] !== layoutDelegate || $[4] !== listBoxRef || $[5] !== popoverRefLikeValue) {
    t3 = {
      ...props,
      buttonRef,
      inputRef,
      layoutDelegate,
      listBoxRef,
      popoverRef: popoverRefLikeValue
    };
    $[0] = props;
    $[1] = buttonRef;
    $[2] = inputRef;
    $[3] = layoutDelegate;
    $[4] = listBoxRef;
    $[5] = popoverRefLikeValue;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const {
    buttonProps,
    descriptionProps,
    errorMessageProps,
    inputProps,
    labelProps,
    listBoxProps
  } = useComboboxMulti(t3, state);
  let t4;
  if ($[7] !== menuWidth || $[8] !== buttonRef || $[9] !== inputRef || $[10] !== fieldRef) {
    t4 = {
      menuWidth,
      buttonRef,
      inputRef,
      fieldRef
    };
    $[7] = menuWidth;
    $[8] = buttonRef;
    $[9] = inputRef;
    $[10] = fieldRef;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  const popoverStyle = usePopoverStyles(t4);
  let t5;
  if ($[12] !== props || $[13] !== state.isOpen || $[14] !== loadingState || $[15] !== inputProps || $[16] !== inputRef || $[17] !== buttonProps || $[18] !== buttonRef) {
    t5 = /*#__PURE__*/jsx(ComboboxInput, {
      ...props,
      isOpen: state.isOpen,
      loadingState: loadingState,
      inputProps: inputProps,
      inputRef: inputRef,
      triggerProps: buttonProps,
      triggerRef: buttonRef
    });
    $[12] = props;
    $[13] = state.isOpen;
    $[14] = loadingState;
    $[15] = inputProps;
    $[16] = inputRef;
    $[17] = buttonProps;
    $[18] = buttonRef;
    $[19] = t5;
  } else {
    t5 = $[19];
  }
  let t6;
  if ($[20] !== props || $[21] !== descriptionProps || $[22] !== errorMessageProps || $[23] !== labelProps || $[24] !== fieldRef || $[25] !== t5) {
    t6 = /*#__PURE__*/jsx(FieldPrimitive, {
      width: "alias.singleLineWidth",
      ...props,
      descriptionProps: descriptionProps,
      errorMessageProps: errorMessageProps,
      labelProps: labelProps,
      ref: fieldRef,
      children: t5
    });
    $[20] = props;
    $[21] = descriptionProps;
    $[22] = errorMessageProps;
    $[23] = labelProps;
    $[24] = fieldRef;
    $[25] = t5;
    $[26] = t6;
  } else {
    t6 = $[26];
  }
  const t7 = align === "end" ? buttonRef : inputRef;
  const t8 = `${direction} ${align}`;
  const t9 = (_state$focusStrategy = state.focusStrategy) !== null && _state$focusStrategy !== void 0 ? _state$focusStrategy : undefined;
  const t10 = loadingState === "loadingMore";
  let t11;
  if ($[27] !== isAsync || $[28] !== loadingState) {
    t11 = () => isAsync && /*#__PURE__*/jsx(ComboboxEmptyState, {
      loadingState: loadingState
    });
    $[27] = isAsync;
    $[28] = loadingState;
    $[29] = t11;
  } else {
    t11 = $[29];
  }
  let t12;
  if ($[30] !== listBoxProps || $[31] !== listBoxRef || $[32] !== t9 || $[33] !== t10 || $[34] !== layoutDelegate || $[35] !== onLoadMore || $[36] !== state || $[37] !== t11) {
    t12 = /*#__PURE__*/jsx(ListBoxBase, {
      ...listBoxProps,
      ref: listBoxRef,
      autoFocus: t9,
      disallowEmptySelection: true,
      focusOnPointerEnter: true,
      isLoading: t10,
      layout: layoutDelegate,
      onLoadMore: onLoadMore,
      state: state,
      UNSAFE_className: listStyles,
      renderEmptyState: t11
    });
    $[30] = listBoxProps;
    $[31] = listBoxRef;
    $[32] = t9;
    $[33] = t10;
    $[34] = layoutDelegate;
    $[35] = onLoadMore;
    $[36] = state;
    $[37] = t11;
    $[38] = t12;
  } else {
    t12 = $[38];
  }
  let t13;
  if ($[39] !== state || $[40] !== popoverStyle || $[41] !== popoverRef || $[42] !== t7 || $[43] !== listBoxRef || $[44] !== t8 || $[45] !== shouldFlip || $[46] !== t12) {
    t13 = /*#__PURE__*/jsx(Popover, {
      state: state,
      UNSAFE_style: popoverStyle,
      ref: popoverRef,
      triggerRef: t7,
      scrollRef: listBoxRef,
      placement: t8,
      hideArrow: true,
      isNonModal: true,
      shouldFlip: shouldFlip,
      children: t12
    });
    $[39] = state;
    $[40] = popoverStyle;
    $[41] = popoverRef;
    $[42] = t7;
    $[43] = listBoxRef;
    $[44] = t8;
    $[45] = shouldFlip;
    $[46] = t12;
    $[47] = t13;
  } else {
    t13 = $[47];
  }
  let t14;
  if ($[48] !== t6 || $[49] !== t13) {
    t14 = /*#__PURE__*/jsxs(Fragment, {
      children: [t6, t13]
    });
    $[48] = t6;
    $[49] = t13;
    $[50] = t14;
  } else {
    t14 = $[50];
  }
  return t14;
});

/**
 * This component is not accessible, use with caution.
 *
 * A multi-combobox combines a text input with a listbox, and allows users to filter a
 * list of options.
 */
const _ComboboxMulti = /*#__PURE__*/React.forwardRef(ComboboxMulti);

export { _Combobox as Combobox, _ComboboxMulti as ComboboxMulti, comboboxClassList };
